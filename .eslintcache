[{"c:\\Projects\\react\\new-year-2021\\src\\index.js":"1","c:\\Projects\\react\\new-year-2021\\src\\App.js":"2","c:\\Projects\\react\\new-year-2021\\src\\reportWebVitals.js":"3","c:\\Projects\\react\\new-year-2021\\src\\components\\home\\index.js":"4","c:\\Projects\\react\\new-year-2021\\src\\components\\home\\Home.js":"5","c:\\Projects\\react\\new-year-2021\\src\\modules\\fireworks.js":"6"},{"size":546,"mtime":1609468640070,"results":"7","hashOfConfig":"8"},{"size":366,"mtime":1609477035046,"results":"9","hashOfConfig":"8"},{"size":362,"mtime":499162500000,"results":"10","hashOfConfig":"8"},{"size":30,"mtime":1609468437944,"results":"11","hashOfConfig":"8"},{"size":4777,"mtime":1609477105508,"results":"12","hashOfConfig":"8"},{"size":10108,"mtime":1609474337221,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"xz7jje",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"16"},"c:\\Projects\\react\\new-year-2021\\src\\index.js",[],["28","29"],"c:\\Projects\\react\\new-year-2021\\src\\App.js",[],"c:\\Projects\\react\\new-year-2021\\src\\reportWebVitals.js",[],"c:\\Projects\\react\\new-year-2021\\src\\components\\home\\index.js",[],"c:\\Projects\\react\\new-year-2021\\src\\components\\home\\Home.js",[],"c:\\Projects\\react\\new-year-2021\\src\\modules\\fireworks.js",["30","31"],"export default () => {\r\n  // when animating on canvas, it is best to use requestAnimationFrame instead of setTimeout or setInterval\r\n  // not supported in all browsers though and sometimes needs a prefix, so we need a shim\r\n//   window.requestAnimFrame = (function () {\r\n//     return (\r\n//       window.requestAnimationFrame ||\r\n//       window.webkitRequestAnimationFrame ||\r\n//       window.mozRequestAnimationFrame ||\r\n//       function (callback) {\r\n//         window.setTimeout(callback, 1000 / 60);\r\n//       }\r\n//     );\r\n//   })();\r\n\r\n  // now we will setup our basic variables for the demo\r\n  var canvas = document.getElementById(\"canvas\"),\r\n    ctx = canvas.getContext(\"2d\"),\r\n    // full screen dimensions\r\n    cw = window.innerWidth,\r\n    ch = window.innerHeight,\r\n    // firework collection\r\n    fireworks = [],\r\n    // particle collection\r\n    particles = [],\r\n    // starting hue\r\n    hue = 120,\r\n    // when launching fireworks with a click, too many get launched at once without a limiter, one launch per 5 loop ticks\r\n    limiterTotal = 5,\r\n    limiterTick = 0,\r\n    // this will time the auto launches of fireworks, one launch per 80 loop ticks\r\n    timerTotal = 80,\r\n    timerTick = 0,\r\n    mousedown = false,\r\n    // mouse x coordinate,\r\n    mx,\r\n    // mouse y coordinate\r\n    my;\r\n\r\n  // set canvas dimensions\r\n  canvas.width = cw;\r\n  canvas.height = ch;\r\n\r\n  // now we are going to setup our function placeholders for the entire demo\r\n\r\n  // get a random number within a range\r\n  function random(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n\r\n  // calculate the distance between two points\r\n  function calculateDistance(p1x, p1y, p2x, p2y) {\r\n    var xDistance = p1x - p2x,\r\n      yDistance = p1y - p2y;\r\n    return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));\r\n  }\r\n\r\n  // create firework\r\n  function Firework(sx, sy, tx, ty) {\r\n    // actual coordinates\r\n    this.x = sx;\r\n    this.y = sy;\r\n    // starting coordinates\r\n    this.sx = sx;\r\n    this.sy = sy;\r\n    // target coordinates\r\n    this.tx = tx;\r\n    this.ty = ty;\r\n    // distance from starting point to target\r\n    this.distanceToTarget = calculateDistance(sx, sy, tx, ty);\r\n    this.distanceTraveled = 0;\r\n    // track the past coordinates of each firework to create a trail effect, increase the coordinate count to create more prominent trails\r\n    this.coordinates = [];\r\n    this.coordinateCount = 3;\r\n    // populate initial coordinate collection with the current coordinates\r\n    while (this.coordinateCount--) {\r\n      this.coordinates.push([this.x, this.y]);\r\n    }\r\n    this.angle = Math.atan2(ty - sy, tx - sx);\r\n    this.speed = 2;\r\n    this.acceleration = 1.05;\r\n    this.brightness = random(50, 70);\r\n    // circle target indicator radius\r\n    this.targetRadius = 1;\r\n  }\r\n\r\n  // update firework\r\n  Firework.prototype.update = function (index) {\r\n    // remove last item in coordinates array\r\n    this.coordinates.pop();\r\n    // add current coordinates to the start of the array\r\n    this.coordinates.unshift([this.x, this.y]);\r\n\r\n    // cycle the circle target indicator radius\r\n    if (this.targetRadius < 8) {\r\n      this.targetRadius += 0.3;\r\n    } else {\r\n      this.targetRadius = 1;\r\n    }\r\n\r\n    // speed up the firework\r\n    this.speed *= this.acceleration;\r\n\r\n    // get the current velocities based on angle and speed\r\n    var vx = Math.cos(this.angle) * this.speed,\r\n      vy = Math.sin(this.angle) * this.speed;\r\n    // how far will the firework have traveled with velocities applied?\r\n    this.distanceTraveled = calculateDistance(\r\n      this.sx,\r\n      this.sy,\r\n      this.x + vx,\r\n      this.y + vy\r\n    );\r\n\r\n    // if the distance traveled, including velocities, is greater than the initial distance to the target, then the target has been reached\r\n    if (this.distanceTraveled >= this.distanceToTarget) {\r\n      createParticles(this.tx, this.ty);\r\n      // remove the firework, use the index passed into the update function to determine which to remove\r\n      fireworks.splice(index, 1);\r\n    } else {\r\n      // target not reached, keep traveling\r\n      this.x += vx;\r\n      this.y += vy;\r\n    }\r\n  };\r\n\r\n  // draw firework\r\n  Firework.prototype.draw = function () {\r\n    ctx.beginPath();\r\n    // move to the last tracked coordinate in the set, then draw a line to the current x and y\r\n    ctx.moveTo(\r\n      this.coordinates[this.coordinates.length - 1][0],\r\n      this.coordinates[this.coordinates.length - 1][1]\r\n    );\r\n    ctx.lineTo(this.x, this.y);\r\n    ctx.strokeStyle = \"hsl(\" + hue + \", 100%, \" + this.brightness + \"%)\";\r\n    ctx.stroke();\r\n\r\n    ctx.beginPath();\r\n    // draw the target for this firework with a pulsing circle\r\n    ctx.arc(this.tx, this.ty, this.targetRadius, 0, Math.PI * 2);\r\n    ctx.stroke();\r\n  };\r\n\r\n  // create particle\r\n  function Particle(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n    // track the past coordinates of each particle to create a trail effect, increase the coordinate count to create more prominent trails\r\n    this.coordinates = [];\r\n    this.coordinateCount = 5;\r\n    while (this.coordinateCount--) {\r\n      this.coordinates.push([this.x, this.y]);\r\n    }\r\n    // set a random angle in all possible directions, in radians\r\n    this.angle = random(0, Math.PI * 2);\r\n    this.speed = random(1, 10);\r\n    // friction will slow the particle down\r\n    this.friction = 0.95;\r\n    // gravity will be applied and pull the particle down\r\n    this.gravity = 1;\r\n    // set the hue to a random number +-50 of the overall hue variable\r\n    this.hue = random(hue - 50, hue + 50);\r\n    this.brightness = random(50, 80);\r\n    this.alpha = 1;\r\n    // set how fast the particle fades out\r\n    this.decay = random(0.015, 0.03);\r\n  }\r\n\r\n  // update particle\r\n  Particle.prototype.update = function (index) {\r\n    // remove last item in coordinates array\r\n    this.coordinates.pop();\r\n    // add current coordinates to the start of the array\r\n    this.coordinates.unshift([this.x, this.y]);\r\n    // slow down the particle\r\n    this.speed *= this.friction;\r\n    // apply velocity\r\n    this.x += Math.cos(this.angle) * this.speed;\r\n    this.y += Math.sin(this.angle) * this.speed + this.gravity;\r\n    // fade out the particle\r\n    this.alpha -= this.decay;\r\n\r\n    // remove the particle once the alpha is low enough, based on the passed in index\r\n    if (this.alpha <= this.decay) {\r\n      particles.splice(index, 1);\r\n    }\r\n  };\r\n\r\n  // draw particle\r\n  Particle.prototype.draw = function () {\r\n    ctx.beginPath();\r\n    // move to the last tracked coordinates in the set, then draw a line to the current x and y\r\n    ctx.moveTo(\r\n      this.coordinates[this.coordinates.length - 1][0],\r\n      this.coordinates[this.coordinates.length - 1][1]\r\n    );\r\n    ctx.lineTo(this.x, this.y);\r\n    ctx.strokeStyle =\r\n      \"hsla(\" +\r\n      this.hue +\r\n      \", 100%, \" +\r\n      this.brightness +\r\n      \"%, \" +\r\n      this.alpha +\r\n      \")\";\r\n    ctx.stroke();\r\n  };\r\n\r\n  // create particle group/explosion\r\n  function createParticles(x, y) {\r\n    // increase the particle count for a bigger explosion, beware of the canvas performance hit with the increased particles though\r\n    var particleCount = 30;\r\n    while (particleCount--) {\r\n      particles.push(new Particle(x, y));\r\n    }\r\n  }\r\n\r\n  // main demo loop\r\n  function loop() {\r\n    // this function will run endlessly with requestAnimationFrame\r\n    window.requestAnimationFrame(loop);\r\n\r\n    // increase the hue to get different colored fireworks over time\r\n    //hue += 0.5;\r\n\r\n    // create random color\r\n    hue = random(0, 360);\r\n\r\n    // normally, clearRect() would be used to clear the canvas\r\n    // we want to create a trailing effect though\r\n    // setting the composite operation to destination-out will allow us to clear the canvas at a specific opacity, rather than wiping it entirely\r\n    ctx.globalCompositeOperation = \"destination-out\";\r\n    // decrease the alpha property to create more prominent trails\r\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\r\n    ctx.fillRect(0, 0, cw, ch);\r\n    // change the composite operation back to our main mode\r\n    // lighter creates bright highlight points as the fireworks and particles overlap each other\r\n    ctx.globalCompositeOperation = \"lighter\";\r\n\r\n    // loop over each firework, draw it, update it\r\n    var i = fireworks.length;\r\n    while (i--) {\r\n      fireworks[i].draw();\r\n      fireworks[i].update(i);\r\n    }\r\n\r\n    // loop over each particle, draw it, update it\r\n    var i = particles.length;\r\n    while (i--) {\r\n      particles[i].draw();\r\n      particles[i].update(i);\r\n    }\r\n\r\n    // launch fireworks automatically to random coordinates, when the mouse isn't down\r\n    if (timerTick >= timerTotal) {\r\n      if (!mousedown) {\r\n        // start the firework at the bottom middle of the screen, then set the random target coordinates, the random y coordinates will be set within the range of the top half of the screen\r\n        fireworks.push(\r\n          new Firework(cw / 2, ch, random(0, cw), random(0, ch / 2))\r\n        );\r\n        timerTick = 0;\r\n      }\r\n    } else {\r\n      timerTick++;\r\n    }\r\n\r\n    // limit the rate at which fireworks get launched when mouse is down\r\n    if (limiterTick >= limiterTotal) {\r\n      if (mousedown) {\r\n        // start the firework at the bottom middle of the screen, then set the current mouse coordinates as the target\r\n        fireworks.push(new Firework(cw / 2, ch, mx, my));\r\n        limiterTick = 0;\r\n      }\r\n    } else {\r\n      limiterTick++;\r\n    }\r\n  }\r\n\r\n  // mouse event bindings\r\n  // update the mouse coordinates on mousemove\r\n  canvas.addEventListener(\"mousemove\", function (e) {\r\n    mx = e.pageX - canvas.offsetLeft;\r\n    my = e.pageY - canvas.offsetTop;\r\n  });\r\n\r\n  // toggle mousedown state and prevent canvas from being selected\r\n  canvas.addEventListener(\"mousedown\", function (e) {\r\n    e.preventDefault();\r\n    mousedown = true;\r\n  });\r\n\r\n  canvas.addEventListener(\"mouseup\", function (e) {\r\n    e.preventDefault();\r\n    mousedown = false;\r\n  });\r\n\r\n  // once the window loads, we are ready for some fireworks!\r\n  window.onload = loop;\r\n};\r\n",{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","replacedBy":"35"},{"ruleId":"36","severity":1,"message":"37","line":1,"column":1,"nodeType":"38","endLine":299,"endColumn":3},{"ruleId":"39","severity":1,"message":"40","line":248,"column":9,"nodeType":"41","messageId":"42","endLine":248,"endColumn":10},"no-native-reassign",["43"],"no-negated-in-lhs",["44"],"import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","no-redeclare","'i' is already defined.","Identifier","redeclared","no-global-assign","no-unsafe-negation"]